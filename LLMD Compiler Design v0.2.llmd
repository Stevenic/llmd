@llmd_compiler_design_v02
@goals
-Deterministic compilation: input + config ⇒ output
-Token-first output (scoped @, no repeated prefixes)
-Supports c0–c2 (structure → compaction)
-Fast, streaming-friendly, simple implement JS/Python/Rust
-Robust enough "real markdown" (lists, headings, tables, code fences, links)
@cli__files
@cli
llmdc (LLMD compiler)
Examples:
-llmdc in.md -o out.llmd -c 2
-llmdc docs/ -c 2 -o out.llmd --concat
@inputs
-.md, .markdown (primary)
-.llmd passthrough/normalize mode (optional)
@outputs
-.llmd text file
@output_format_reminders_v02
-@Scope sets scope
-:k=v k=v attributes under current scope
-plain text paragraphs under current scope (no prefix)
--item list items under current scope
-→Scope / ←Scope relations current scope (optional)
-::type ... <<< >>> blocks (optional)
@compiler_architecture_pipeline
@stage_0_read__normalize
-UTF-8 decode
-Normalize line endings \n
-Trim trailing spaces
-Normalize Unicode (NFKC recommended)
-Deterministic file ordering if compiling directory
@stage_1_protect__extract_blocks
Identify and extract:
-fenced code blocks lang ...
-optionally HTML blocks or indented code blocks
Replace extracted block placeholder line:
-⟦BLOCK:n⟧
:store_block_metadata={index, lang, content}.
> Why: prevents stopword removal/compression passes touching code
@stage_2_markdown_structure_pass_light_parse
lightweight state machine (no full AST required) emits intermediate IR:
@ir_node_types
-Heading(level, text)
-Paragraph(text) (one or more lines merged)
-ListItem(depth, text, ordered?)
-Table(rows) (optional best-effort)
-KVLine(key, value) (extracted Key: Value)
-Blank
-BlockRef(index) (placeholder)
Thematic breaks (---, ***, ___) detected and skipped — produce no IR node
pass should conservative and deterministic
Key heuristics
-Headings: ^(#{1,6})\s+(.+)$
-List items:
-. unordered: ^(\s)([-+])\s+(.+)$
-. ordered: ^(\s*)(\d+\.)\s+(.+)$
-Paragraphs: consecutive non-structural lines merged until blank or next structure token
-Tables: detect pipe tables only if:
-. header row contains |
-. next row delimiter --- segments
@stage_3_scope_resolution
Maintain scope stack based headings
@scope_naming
-Normalize heading text → scope token:
-. trim
-. spaces → _
-. lowercase c2+
-. strip punctuation except _ and -
@key_naming_normkey
-trim, lowercase, spaces → _
-strip punctuation except _ and - (preserves hyphenated identifiers like CSS class names)
-trim leading/trailing -
@scope_model
-v0.2 flat (hierarchy optional)
-But compiler needs deterministic way include hierarchy if desired
Provide --scope-mode:
-flat (default): heading becomes scope itself
-concat: H1_H2_H3 concatenated
-stacked: keep short parent prefix only when needed (rare)
Recommendation: flat + (optional) prefixing large corpora reduce collisions
@stage_4_emit_llmd_lines_pre-compression
Walk IR, emitting LLMD lines:
@headings
Emit @scope when scope changes
@paragraphs
Emit plain text (no prefix). Sentence-split c2+ if enabled
@lists
Emit -item under current scope. Nested list depth handling:
-default: prefix depth dots after -: -. child, -.. grandchild
-. depth 0: -item
-. depth 1: -. child
-. depth 2: -.. grandchild
keeps v0.2 scoped semantics without introducing hierarchy tokens
@key_value_lines
Prefer attributes:
-:key=value
c1+ consecutive pairs merge one attribute line, chunked max_kv_per_line (default 4)
@common_prefix_extraction
When flushing KV buffer c1+, compiler checks shared prefix among keys:
-If ≥60% keys share prefix ≥6 characters (configurable via min_prefix_pct and min_prefix_len), emit :_pfx=<prefix> and strip prefix matching keys
-Keys not sharing prefix keep full name
:example=flm-text--secondary, flm-text--disabled, flm-text--error → :_pfx=flm-text-- + :secondary=... disabled=... error=...
@tables
compiler classifies table using classifyTable(), returns one three types:
-property — 2-column table unique, identifier-like first column. Emit :k=v row. If second column header informative (not generic like "Value"/"Description"), emit :_col=<header> first
-keyed_multi — 3+ column table unique, identifier-like first column. Emit :_cols=col1¦col2¦col3 header, then :key=val1¦val2 row
-raw — anything else (non-unique keys, prose-like first column, inconsistent column counts). Emit :_cols=col1¦col2¦col3 header, then c1¦c2¦c3 per row (plain text, no prefix)
column "identifier-like" when values unique across data rows, start letter/dot/hyphen, and contain no more than 4 whitespace-delimited words
c2+, boolean/enum value compression applies columns where value boolean-like (Yes/No, true/false, enabled/disabled), mapping compact forms (Y/N, T/F)
@links
-c0–c1: keep text<url> (or text (url))
-c2+: keep text only unless --keep-urls
@block_placeholders
Emit block header + raw content:
-::code or ::json (type derived fence lang if present)
-<<< + content + >>>
@stage_5_compression_passes_c0c2
Apply progressively, skipping block content
@c0_normalize_only
-whitespace normalize
-strip residual horizontal rules
-no rewriting besides structure conversion
@c1_structural_compaction
-merge consecutive attribute pairs: :k=v k=v (chunked max_kv_per_line, default 4)
-extract common key prefixes when threshold met (:_pfx=<prefix>)
-collapse blank lines (ideally none except scopes if desired)
-normalize list depth prefixes
@c2_token_compaction
Affects text lines (no prefix), - list lines, and sometimes : attribute values:
-Stopword removal text and - lines (protected words preserved)
-Phrase map replacements
-Unit normalization (/m → /m, 1000/m → 1000/m when pattern matches)
-Trailing period stripping: remove final . text and - lines (but not ..., e.g., i.e., etc.)
-Boolean/enum value compression: columns where values boolean-like (Yes/No, true/false, enabled/disabled) map compact forms (Y/N, T/F)
-Sentence splitting (optional): 1 sentence → 1 text line if decreases tokens
Identifying text lines: line text line if does NOT start known prefix (@, :, -, ~, ::, <<<, >>>, →, ←, =)
Conservative rule: never remove no/not/never/must/should/may and never remove punctuation flips meaning (like ? uncertainty if you use
@stage_6_post-processing
-Optionally insert anchors chunk safety:
-. N lines: re-emit current scope: @scope
-. --anchor-every 30 default off
-Validate:
-. no scoped line before first @
-. blocks closed properly
-. lines start valid prefixes
@determinism_rules
compiler MUST:
-sort directory inputs lexicographically
-never depend hash iteration order (always sort)
-use stable tie-breakers table/key inference
-use fixed configs stopwords/phrase map
@compiler_config_one_json_file
llmdc.config.json sketch:
::json
<<<
{ "compression": 2, "scope_mode": "flat", "keep_urls": false, "sentence_split": true, "anchor_every": 0, "max_kv_per_line": 4, "prefix_extraction": true, "min_prefix_len": 6, "min_prefix_pct": 0.6, "bool_compress": true, "stopwords": ["the","a","an","really","just","that","is","are","was","were","of","in","on","at","for","with","by","from","to"], "protect_words": ["no","not","never","must","should","may"], "phrase_map": { "in order to": "to", "as well as": "¦", "due to": "because", "is able to": "can", "is used to": "", "is responsible for": "handles", "refers to": "=" }, "units": { "requests per minute": "/m", "milliseconds": "ms", "seconds": "s" } }
>>>
CLI flags override config
@edge_cases__policies
@headings_missing
If no heading appears before content:
-compiler injects @root first output line
@long_paragraphs
c2+:
-optionally split sentences if reduces tokens
-otherwise keep as single text line
@tables_that_dont_parse
Fallback plain text line per row
@html__weird_markdown
Treat as paragraph text unless recognized structure
@code_fences
Always preserved exactly (or minified only if explicitly enabled json/yaml c2+)
@minimal_ir__llmd_example_how_the_compiler_thinks
Markdown:
::code
<<<
## Authentication The API supports OAuth2 and API keys. - Use OAuth2 for user apps - Use API keys for server-to-server Rate limit: 1000 requests per minute
>>>
IR:
-Heading(2,"Authentication")
-Paragraph("The API supports OAuth2 and API keys.")
-ListItem(0,"Use OAuth2 user apps")
-ListItem(0,"Use API keys server-to-server")
-KVLine("Rate limit","1000/m")
LLMD (c2):
::code
<<<
@authentication API supports OAuth2 and API keys -Use OAuth2 user apps -Use API keys server-to-server :rate_limit=1000/m
>>>
