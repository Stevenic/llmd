@llmd_v01__specification
>---
@1_design_principles
>Scope is implicit (never repeat full paths unless scope changes)
>Each line = one semantic unit
>Minimal structural symbols
>Lossy allowed
>Deterministic compilation
>Optimized for token count, not human reconstruction
>---
@2_file_structure
>LLMD is UTF-8, line-oriented format.
>Each non-empty line begins with exactly one of:
::code
<<<
~ metadata @ scope declaration : attribute line (scoped) > item line (scoped) -> relation (scoped) :: block start (scoped)
>>>
>Anything else is invalid outside block.
>---
@3_scope_model_core_mechanism
@31_scope_declaration
::code
<<<
@node
>>>
>Sets current scope.
>All following lines inherit this scope.
>Scope persists until next @.
>Scope names:
>SHOULD be short
>SHOULD be normalized (see §7)
>SHOULD NOT contain / (hierarchy flattened by compiler)
>Example:
::code
<<<
@Auth :methods=oauth2|apikey rate=1000/m >oauth2 user-app
>>>
>No repeated Auth/... prefixes.
>---
@4_line_types
>---
@41_metadata_line
>Optional. SHOULD appear only once at top.
::code
<<<
~k=v k=v
>>>
>No pipes. Space-separated pairs.
>Example:
::code
<<<
~v=0.2 c=2 title=api_spec
>>>
>Metadata SHOULD be omitted at high compression unless required.
>---
@42_attribute_line
>Structured facts for current scope.
::code
<<<
:k=v k=v k=v
>>>
>Rules:
>No leading scope prefix
>Keys lowercase
>No spaces around =
>Space separates pairs
>Example:
::code
<<<
:methods=oauth2|apikey rate=1000/m required=true
>>>
>Preferred over prose whenever possible.
@reserved_meta-attributes
>Keys prefixed with _ are reserved for compiler-generated metadata:
>:_col=<header> — column header for 2-column property table (emitted when value column header is informative)
>:_cols=col1|col2|col3 — column headers for multi-column table
>:_pfx=<prefix> — common prefix extracted from subsequent keys; reader should prepend this prefix to restore full key names
@chunked_emission
>At c1+, consecutive :k=v pairs are merged onto one line. When number of pairs exceeds max_kv_per_line (default 4), they are split across multiple : lines for chunk-safe splitting:
::code
<<<
:k1=v1 k2=v2 k3=v3 k4=v4 :k5=v5 k6=v6 k7=v7 k8=v8 :k9=v9
>>>
>---
@43_item_line
>Unstructured or semi-structured statement.
::code
<<<
>text...
>>>
>No space required after > (saves tokens).
>Example:
::code
<<<
>oauth2 user-app >apikey svc-svc
>>>
>Compiler MAY:
>Remove stopwords (c2+)
>Apply phrase map replacements (c2)
>---
@44_relation_line
>Declares relation from current scope.
::code
<<<
->Node <-Node =Node
>>>
>Optional uncertainty:
::code
<<<
->Node?
>>>
>Example:
::code
<<<
@API ->DB ->Cache?
>>>
>This means:
>API depends on DB API optionally depends on Cache
>No repeated prefixes.
>---
@45_block_line
>Used for code or preserved literals.
::code
<<<
::type <<< raw content >>>
>>>
>Example:
::code
<<<
::json <<< {"retry":3,"backoff":"exp"} >>>
>>>
>Rules:
><<< and >>> must be alone on their lines
>Block content is raw and not parsed
>Compiler MAY minify JSON/YAML at c2+
>---
@5_hierarchy_handling
>Hierarchy is flattened at compile time.
>Example Markdown:
::code
<<<
# API ## Authentication
>>>
>Compiler options:
@option_a_default_merge_path_segments
::code
<<<
@API @Auth
>>>
@option_b_concatenate
::code
<<<
@API_Auth
>>>
>LLMD itself does NOT encode explicit multi-level hierarchy. Hierarchy is compiler concern, not runtime syntax.
>This removes / token repetition.
>---
@6_compression_levels_normative
>c ∈ {0,1,2}
>---
@c0__structural_normalize
>Convert Markdown structure
>Preserve most wording
>Preserve URLs
>Preserve punctuation
:goal=clean but not compressed.
>---
@c1__compact_structure
>Convert lists → >
>Convert Key: Value → :k=v
>Collapse whitespace
>Remove extra blank lines
>No stopword removal yet
>---
@c2__token_compaction
>Remove stopwords (configurable list)
>Remove filler phrases:
>. to → to
>. because → because
>. can → can
>Normalize units:
>. "1000/m" → 1000/m
>Convert obvious sentences into attributes
>Drop URLs unless flagged
>Must preserve:
>negation words
>modal strength (must/should/may)
>---
@7_normalization_rules
@71_scope_names
>At minimum:
>Trim whitespace
>Replace spaces with _
>At c2+:
>Lowercase
>---
@72_keys
>Always:
>Lowercase
>Spaces → _
>Strip punctuation except _ and -
>Trim leading/trailing -
>Example:
::code
<<<
Rate Limit → rate_limit flm-text--secondary → flm-text--secondary
>>>
>Preserving - is critical for CSS class names and other hyphenated identifiers.
>---
@73_whitespace
>Single LF line endings
>No trailing spaces
>No multiple blank lines
>No extra spaces around operators
>---
@8_valid_file_rules
>valid LLMD file must:
>Begin with optional metadata
>Declare scope before any scoped line
>Not mix block markers
>Not contain unknown line prefixes
>---
@9_example_token-optimized
>Original Markdown (64 tokens approx):
::code
<<<
## Authentication The API supports authentication via OAuth2 and API keys. - Use OAuth2 for user-facing apps. - Use API keys for server-to-server. Rate limit: 1000 requests per minute.
>>>
>LLMD v0.1 (c2):
::code
<<<
@Auth :methods=oauth2|apikey rate=1000/m >oauth2 user-app >apikey svc-svc
>>>
>~27 tokens
>No repeated paths. No verbose prose. No unnecessary punctuation.
>---
@10_why_v01_compresses_better
>Compared to v0.1:
>Removed:
>Path repetition
>Pipes in metadata
>Repeated scope prefixes
>Hierarchical separators
>Verbose block headers
>Everything now leans toward:
>Short scope
>Short keys
>Minimal structure
>---
@11_deterministic_compiler_model
>Minimal pipeline:
>Extract Markdown structure
>Track current heading → scope
>Emit @scope when heading changes
>Convert lists → >
>Convert simple pairs → :k=v
>Apply compression rules by level
>Emit file
>No AST required (line-based parser is sufficient).
>---
@12_optional_future_extensions_not_in_v01_core
>Stable scope IDs for chunk-safe slicing
>Inline scope hash markers
>Global term alias table at file top
>---
@final_summary
>LLMD v0.1 is:
>Scoped
>Minimal
>Deterministic
>Lossy by design
>Token-optimized
>Easy to implement
>Proven to reduce tokens substantially
