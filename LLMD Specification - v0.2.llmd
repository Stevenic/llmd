@llmd_v02__specification
@1_design_principles
-Scope implicit (never repeat full paths unless scope changes)
-line = one semantic unit
-Minimal structural symbols
-Lossy allowed
-Deterministic compilation
-Optimized token count, not human reconstruction
@2_file_structure
LLMD UTF-8, line-oriented format
non-empty line begins exactly one
::code
<<<
~ metadata @ scope declaration : attribute line (scoped) plain text (no prefix — paragraphs, prose) - list item (scoped, both ordered and unordered) → forward relation (scoped) ← reverse relation (scoped) = equivalence relation (scoped) :: block start (scoped)
>>>
line plain text if does not start above prefixes
Horizontal rules (---, ***, ___) stripped parsing and never appear output
@3_scope_model_core_mechanism
@31_scope_declaration
::code
<<<
@node
>>>
-Sets current scope
-following lines inherit scope
-Scope persists until next @
Scope names:
-SHOULD short
-SHOULD normalized (see §7)
-SHOULD NOT contain / (hierarchy flattened compiler)
Example:
::code
<<<
@Auth :methods=oauth2¦apikey rate=1000/m -oauth2 user-app
>>>
No repeated Auth/... prefixes
@4_line_types
@41_metadata_line
Optional. SHOULD appear only once top
::code
<<<
~k=v k=v
>>>
No pipes. Space-separated pairs
Example:
::code
<<<
~v=0.2 c=2 title=api_spec
>>>
Metadata SHOULD omitted high compression unless required
@42_attribute_line
Structured facts current scope
::code
<<<
:k=v k=v k=v
>>>
Rules:
-No leading scope prefix
-Keys lowercase
-No spaces around =
-Space separates pairs
-¦ (U+00A6, broken bar) separates multiple values within single attribute
-Split first = separate key value. Keys never contain =
Example:
::code
<<<
:methods=oauth2¦apikey rate=1000/m required=true
>>>
Preferred prose whenever possible
@reserved_meta-attributes
Keys prefixed _ reserved compiler-generated metadata:
-:_col=<header> — column header 2-column property table (emitted when value column header informative)
-:_cols=col1¦col2¦col3 — column headers multi-column table
-:_pfx=<prefix> — common prefix extracted subsequent keys; reader should prepend prefix restore full key names
@chunked_emission
c1+, consecutive :k=v pairs merged onto one line. When number pairs exceeds max_kv_per_line (default 4), split across multiple : lines chunk-safe splitting:
::code
<<<
:k1=v1 k2=v2 k3=v3 k4=v4 :k5=v5 k6=v6 k7=v7 k8=v8 :k9=v9
>>>
@43_text_line
Unstructured prose or paragraph content. Text lines no prefix — plain text
::code
<<<
platform requires minimum three application nodes
>>>
Example:
::code
<<<
@auth API supports authentication via OAuth2 API keys
>>>
Compiler MAY:
-Remove stopwords (c2+)
-Apply phrase map replacements (c2)
-Strip trailing periods (c2)
@44_list_item_line
ordered and unordered Markdown lists compile - prefixed lines
::code
<<<
-item text
>>>
Nested list depth uses . prefixes:
-depth 0: -item
-depth 1: -. child
-depth 2: -.. grandchild
Example:
::code
<<<
@compute -Application nodes: 3 minimum -. high availability recommended -Worker nodes: 2 minimum
>>>
@45_relation_line
Declares relation current scope
::code
<<<
→Node ←Node =Node
>>>
Optional uncertainty:
::code
<<<
→Node?
>>>
Example:
::code
<<<
@API →DB →Cache?
>>>
means:
API depends DB API optionally depends Cache
No repeated prefixes
@46_block_line
Used code or preserved literals
::code
<<<
::type <<< raw content >>>
>>>
Example:
::code
<<<
::json <<< {"retry":3,"backoff":"exp"} >>>
>>>
Rules:
-<<< and >>> must alone lines
-Block content raw and not parsed
-Compiler MAY minify JSON/YAML c2+
@5_hierarchy_handling
Hierarchy flattened compile time
Example Markdown:
::code
<<<
# API ## Authentication
>>>
Compiler options:
@option_a_default_merge_path_segments
::code
<<<
@API @Auth
>>>
@option_b_concatenate
::code
<<<
@API_Auth
>>>
LLMD itself does NOT encode explicit multi-level hierarchy. Hierarchy compiler concern, not runtime syntax
removes / token repetition
@6_compression_levels_normative
c ∈ {0,1,2}
@c0__structural_normalize
-Convert Markdown structure
-Preserve most wording
-Preserve URLs
-Preserve punctuation
-Strip horizontal rules (---, ***, ___)
:goal=clean but not compressed.
@c1__compact_structure
-Convert lists → -
-Convert Key: Value → :k=v
-Collapse whitespace
-Remove extra blank lines
-No stopword removal yet
@c2__token_compaction
-Remove stopwords (configurable list)
-Remove filler phrases:
-. →
-. because → because
-. can → can
-Normalize units:
-. "1000/m" → 1000/m
-Strip trailing periods text and list lines (but not ..., e.g., i.e., etc.)
-Convert obvious sentences attributes
-Drop URLs unless flagged
Must preserve:
-negation words
-modal strength (must/should/may)
@7_normalization_rules
@71_scope_names
minimum:
-Trim whitespace
-Replace spaces _
c2+:
-Lowercase
@72_keys
Always:
-Lowercase
-Spaces → _
-Strip punctuation except _ and -
-Trim leading/trailing -
Example:
::code
<<<
Rate Limit → rate_limit flm-text--secondary → flm-text--secondary
>>>
Preserving - critical CSS class names and hyphenated identifiers
@73_whitespace
-Single LF line endings
-No trailing spaces
-No multiple blank lines
-No extra spaces around operators
@8_valid_file_rules
valid LLMD file must:
-Begin optional metadata
-Declare scope before scoped line
-Not mix block markers
-Not contain unknown line prefixes
@9_example_token-optimized
Original Markdown (64 tokens approx):
::code
<<<
## Authentication The API supports authentication via OAuth2 and API keys. - Use OAuth2 for user-facing apps. - Use API keys for server-to-server. Rate limit: 1000 requests per minute.
>>>
LLMD v0.2 (c2):
::code
<<<
@authentication API supports authentication via OAuth2 and API keys -Use OAuth2 user-facing apps -Use API keys server-to-server :rate_limit=1000/m.
>>>
~22 tokens
No repeated paths. No verbose prose. No unnecessary punctuation
@10_why_v02_compresses_better
Compared v0.1:
Removed:
-> prefix text line (saves 1 token per line)
-Trailing periods text and list lines
-Horizontal rules (no semantic value)
Added:
-- prefix distinguishes list items prose
-→ / ← Unicode arrows replace -> / <-
-Expanded stopword and phrase map more aggressive c2
@11_deterministic_compiler_model
Minimal pipeline:
-Extract Markdown structure
-Track current heading → scope
-Emit @scope when heading changes
-Convert lists → -
-Convert simple pairs → :k=v
-Apply compression rules level
-Emit file
No AST required (line-based parser sufficient)
@12_optional_future_extensions_not_in_v02_core
-Stable scope IDs chunk-safe slicing
-Inline scope hash markers
-Global term alias table file top
@final_summary
LLMD v0.2
-Scoped
-Minimal
-Deterministic
-Lossy design
-Token-optimized
-Easy implement
-Proven reduce tokens substantially
