@llmd_compiler_design_v01
@goals
>Deterministic compilation: same input + config ⇒ same output
>Token-first output (scoped @, no repeated prefixes)
>Supports c0–c2 (structure → compaction)
>Fast, streaming-friendly, simple to implement in JS/Python
>Robust enough for “real markdown” (lists, headings, tables, code fences, links)
>---
@cli__files
@cli
>llmdc (LLMD compiler)
>Examples:
>llmdc in.md -o out.llmd -c 2
>llmdc docs/ -c 2 -o out.llmd --concat
@inputs
>.md, .markdown (primary)
>.llmd passthrough/normalize mode (optional)
@outputs
>.llmd text file
>---
@output_format_reminders_v02_scoped
>@Scope sets scope
>:k=v k=v attributes under current scope
>>text items under current scope
>->Scope relations from current scope (optional)
>::type ... <<< >>> blocks (optional)
>---
@compiler_architecture_pipeline
@stage_0_read__normalize
>UTF-8 decode
>Normalize line endings to \n
>Trim trailing spaces
>Normalize Unicode (NFKC recommended)
>Deterministic file ordering if compiling directory
@stage_1_protect__extract_blocks
>Identify and extract:
>fenced code blocks lang ...
>optionally HTML blocks or indented code blocks
>Replace each extracted block with placeholder line:
>⟦BLOCK:n⟧
:store_block_metadata={index, lang, content}.
>> Why: prevents stopword removal/compression passes from touching code.
@stage_2_markdown_structure_pass_light_parse
>lightweight state machine (no full AST required) emits intermediate IR:
@ir_node_types
>Heading(level, text)
>Paragraph(text) (one or more lines merged)
>ListItem(depth, text, ordered?)
>Table(rows) (optional best-effort)
>KVLine(key, value) (extracted from Key: Value)
>Blank
>BlockRef(index) (placeholder)
>This pass should be conservative and deterministic.
>Key heuristics
>Headings: ^(#{1,6})\s+(.+)$
>List items:
>. unordered: ^(\s)([-+])\s+(.+)$
>. ordered: ^(\s*)(\d+\.)\s+(.+)$
>Paragraphs: consecutive non-structural lines merged until blank or next structure token
>Tables: detect pipe tables only if:
>. header row contains |
>. next row is delimiter with --- segments
@stage_3_scope_resolution
>Maintain scope stack based on headings.
@scope_naming
>Normalize heading text → scope token:
>. trim
>. spaces → _
>. lowercase at c2+
>. strip punctuation except _ and -
@key_naming_normkey
>trim, lowercase, spaces → _
>strip punctuation except _ and - (preserves hyphenated identifiers like CSS class names)
>trim leading/trailing -
@scope_model
>v0.2 is flat (hierarchy optional)
>But compiler needs deterministic way to include hierarchy if desired.
>Provide --scope-mode:
>flat (default): each heading becomes scope by itself
>concat: H1_H2_H3 concatenated
>stacked: keep short parent prefix only when needed (rare)
>Recommendation: flat + (optional) prefixing in large corpora to reduce collisions.
@stage_4_emit_llmd_lines_pre-compression
>Walk IR, emitting LLMD lines:
@headings
>Emit @scope when scope changes.
@paragraphs
>Emit >paragraph (or sentence-split at c2+)
@lists
>Emit >item under current scope. Nested list depth handling options:
>default: prefix depth in-text: >., >..
>. depth 0: >item
>. depth 1: >. child
>. depth 2: >.. grandchild
>This keeps v0.2 scoped semantics without introducing hierarchy tokens.
@key_value_lines
>Prefer attributes:
>:key=value
>At c1+ consecutive pairs merge into one attribute line, chunked by max_kv_per_line (default 4).
@common_prefix_extraction
>When flushing KV buffer at c1+, compiler checks for shared prefix among keys:
>If ≥60% of keys share prefix of ≥6 characters (configurable via min_prefix_pct and min_prefix_len), emit :_pfx=<prefix> and strip prefix from matching keys.
>Keys not sharing prefix keep their full name.
:example=flm-text--secondary, flm-text--disabled, flm-text--error → :_pfx=flm-text-- + :secondary=... disabled=... error=...
@tables
>compiler classifies each table using classifyTable(), which returns one of three types:
>property — 2-column table with unique, identifier-like first column. Emit :k=v for each row. If second column header is informative (not generic like “Value”/”Description”), emit :_col=<header> first.
>keyed_multi — 3+ column table with unique, identifier-like first column. Emit :_cols=col1|col2|col3 header, then :key=val1|val2 for each row.
>raw — anything else (non-unique keys, prose-like first column, inconsistent column counts). Emit :_cols=col1|col2|col3 header, then >c1|c2|c3 per row.
>column is “identifier-like” when its values are unique across all data rows, start with letter/dot/hyphen, and contain no more than 4 whitespace-delimited words.
>At c2+, boolean/enum value compression applies to columns where every value is boolean-like (Yes/No, true/false, enabled/disabled), mapping them to compact forms (Y/N, T/F).
@links
>c0–c1: keep text<url> (or text (url))
>c2+: keep text only unless --keep-urls
@block_placeholders
>Emit block header + raw content:
>::code or ::json (type derived from fence lang if present)
><<< + content + >>>
@stage_5_compression_passes_c0c2
>Apply progressively, skipping block content.
@c0_normalize_only
>whitespace normalize
>no rewriting besides structure conversion
@c1_structural_compaction
>merge consecutive attribute pairs: :k=v k=v (chunked by max_kv_per_line, default 4)
>extract common key prefixes when threshold is met (:_pfx=<prefix>)
>collapse blank lines (ideally none except between scopes if desired)
>normalize list depth prefixes
@c2_token_compaction
>Only affects > and sometimes values:
>Stopword removal in > lines (protected words preserved)
>Phrase map replacements
>Unit normalization (/m → /m, 1000/m → 1000/m when pattern matches)
>Boolean/enum value compression: columns where all values are boolean-like (Yes/No, true/false, enabled/disabled) map to compact forms (Y/N, T/F)
>Sentence splitting (optional): 1 sentence → 1 > line if it decreases tokens
>Conservative rule: never remove no/not/never/must/should/may and never remove punctuation flips meaning (like ? for uncertainty if you use it).
@stage_6_post-processing
>Optionally insert anchors for chunk safety:
>. every N lines: re-emit current scope: @scope
>. --anchor-every 30 default off
>Validate:
>. no scoped line before first @
>. blocks closed properly
>. lines start with valid prefixes
>---
@determinism_rules
>compiler MUST:
>sort directory inputs lexicographically
>never depend on hash iteration order (always sort)
>use stable tie-breakers in table/key inference
>use fixed configs for stopwords/phrase map
>---
@compiler_config_one_json_file
>llmdc.config.json sketch:
::json
<<<
{ "compression": 2, "scope_mode": "flat", "keep_urls": false, "sentence_split": true, "anchor_every": 0, "max_kv_per_line": 4, "prefix_extraction": true, "min_prefix_len": 6, "min_prefix_pct": 0.6, "bool_compress": true, "stopwords": ["the","a","an","really","just","that"], "protect_words": ["no","not","never","must","should","may"], "phrase_map": { "in order to": "to", "as well as": "|", "due to": "because", "is able to": "can" }, "units": { "requests per minute": "/m", "milliseconds": "ms", "seconds": "s" } }
>>>
>CLI flags override config.
>---
>---
@edge_cases__policies
@headings_missing
>If no heading appears before content:
>compiler injects @root at first output line
@long_paragraphs
>At c2+:
>optionally split sentences if it reduces tokens
>otherwise keep as single > line
@tables_that_dont_parse
>Fallback to > line per row.
@html__weird_markdown
>Treat as paragraph text unless recognized structure.
@code_fences
>Always preserved exactly (or minified only if explicitly enabled for json/yaml at c2+)
>---
@suggested_implementation_plan
@phase_1_mvp
>headings, paragraphs, lists, code fences
>c0–c2
>@root fallback
>deterministic normalization
@phase_2
>key:value extraction → :k=v
>table parsing (pipe tables)
@phase_3
>anchor support
>unit normalization patterns
>sentence splitting heuristics
>---
@minimal_ir__llmd_example_how_the_compiler_thinks
>Markdown:
::code
<<<
## Authentication The API supports OAuth2 and API keys. - Use OAuth2 for user apps - Use API keys for server-to-server Rate limit: 1000 requests per minute
>>>
>IR:
>Heading(2,"Authentication")
>Paragraph("The API supports OAuth2 and API keys.")
>ListItem(0,"Use OAuth2 for user apps")
>ListItem(0,"Use API keys for server-to-server")
>KVLine("Rate limit","1000/m")
>LLMD (c2):
::code
<<<
@auth :methods=oauth2|apikey rate=1000/m >oauth2 user apps >apikey svc-svc
>>>
